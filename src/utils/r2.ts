
import { Env, PresignedUrl } from '../types';

/**
 * Generate a pre-signed URL for R2 bucket operations
 * Note: Using a simplified approach since aws4fetch S3 class has typing issues
 */
export async function getPresignedUrl(
  env: Env,
  method: 'GET' | 'PUT',
  key: string,
  contentType?: string,
  expiresIn: number = 3600
): Promise<PresignedUrl> {
  // In a real implementation, you'd use aws4fetch properly or CloudFlare's R2 presigned URLs
  // This is a simplified placeholder that would need to be implemented with proper S3 compatible signing
  
  // For Cloudflare R2, presigned URLs can be generated by creating an Access Key with S3 API compatibility
  // and then using that with a library like aws4fetch or AWS SDK
  
  // Mock implementation for now
  const url = `https://${env.R2_ACCOUNT_ID}.r2.cloudflarestorage.com/${env.CERT_BUCKET}/${key}?X-Amz-Expires=${expiresIn}`;
  
  return {
    url: url,
    expiresAt: Date.now() + expiresIn * 1000,
  };
}

/**
 * Upload a file directly to R2 from the worker
 */
export async function uploadToR2(
  env: Env,
  key: string,
  data: ArrayBuffer | Uint8Array,
  contentType: string
): Promise<string> {
  try {
    // Using the R2 bucket binding directly
    await env.CERT_BUCKET.put(key, data, {
      httpMetadata: {
        contentType,
      },
    });
    
    // Return a URL to the uploaded object
    return `https://${env.R2_ACCOUNT_ID}.r2.cloudflarestorage.com/${env.CERT_BUCKET}/${key}`;
  } catch (error) {
    console.error('R2 upload error:', error);
    throw new Error(`Failed to upload file to R2: ${error}`);
  }
}

/**
 * Get a public URL for an object in R2
 */
export function getPublicUrl(
  env: Env,
  key: string
): string {
  return `https://${env.R2_ACCOUNT_ID}.r2.cloudflarestorage.com/${env.CERT_BUCKET}/${key}`;
}
